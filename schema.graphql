type Coordinate {
	lat: Float
	lng: Float
}

input CoordinateInput {
	lat: Float
	lng: Float
}

type Driver {
	id: ID
	email: AWSEmail
	fullName: String
	deliveryType: String
	deviceId: String
	deviceType: String
	status: DriverStatus
	createdAt: AWSDateTime
	updatedAt: AWSDateTime	
	trips: [Trip]
}

type Trip {
	id: ID
	driver: Driver
	labelStart: String
	geoStart: Coordinate
	labelEnd: String
	geoEnd: Coordinate
	duration: Float
	distance: Float
	geoFenceId: ID
	clientphone: String
	expireAt: Float
	status: TripStatus
	createdAt: AWSDateTime
	updatedAt: AWSDateTime
}

input DriverInput {
	id: ID
	email: AWSEmail
	fullName: String
	deliveryType: String
	deviceId: String
	deviceType: String
	status: DriverStatus
	createdAt: AWSDateTime
	updatedAt: AWSDateTime	
	trips: [TripInput]
}

input TripInput {
	id: ID
	driver: DriverInput
	geoStart: CoordinateInput
	geoEnd: CoordinateInput
	labelStart: String
	labelEnd: String
	duration: Float
	distance: Float
	geoFenceId: ID
	clientPhone: String
	expireAt: Float
	status: TripStatus
	createdAt: AWSTimestamp
	updatedAt: AWSTimestamp
}

enum TripStatus {  
  completed
  inroute
  accepted
  error
  onhold
}

enum DriverStatus {  
  active
  inactive
  banned
}

type Mutation {
	saveDriver(input: DriverInput): Driver
	delDriver(id: ID!): Driver
	saveTrip(input: TripInput): Trip
	delTrip(id: ID!): Trip	
}

type Query {
	getDriver(id: ID!): Driver
	listDrivers(limit: Int, nextToken: String): PaginatedDrivers
	addDriverTrip(driverId: ID!, tripId: ID!): Driver
	removeDriverTrip(driverId: ID!, tripId: ID!): Driver
	getTrip(id: ID!): Trip
	listTrips(limit: Int, nextToken: String): PaginatedTrips
	statusTrips(status: TripStatus, limit: Int, nextToken: String): PaginatedTrips
}

type PaginatedDrivers {
    drivers: [Driver!]!
    nextToken: String
}

type PaginatedTrips {
    trips: [Trip!]!
    nextToken: String
}

schema {
	query: Query
	mutation: Mutation
}